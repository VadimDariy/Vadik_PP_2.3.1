package web.dao;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;
import web.model.User;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import java.util.List;

@Repository
public class UserDaoImpl implements UserDao {

    @PersistenceContext
    private EntityManager entityManager;
    @Override
    public void addUser(User user) {
        entityManager.persist(user);
    }

    @Override
    public void deleteUserById(Long id) {
        entityManager.createQuery("DELETE FROM User WHERE id = :id").setParameter("id", id).executeUpdate();
    }

    @Override
    public void updateUser(User user) {
        entityManager.merge(user);
    }

    @Override
    public List<User> getAllUsers() {
        return entityManager.createQuery("FROM User", User.class).getResultList();
    }

    @Override
    public User getUserById(Long id) {
        return entityManager.find(User.class, id);
    }
}

/*
 1.      Объявляяем "class UserDaoImpl" и реализуем в нём интерфейс "UserDao"

 2.      @Repository: используем эту аннотацию из Spring Framework для обозначения класса как компонента, который
    обеспечивает доступ к базе данных. Она позволяет Spring автоматически обнаруживать класс как компонент, связанный с
    доступом к данным, и внедрять его в другие компоненты нашего приложения, такие как сервисы или контроллеры.

 3. @PersistenceContext
    private EntityManager entityManager;

         @PersistenceContext: используем именно эту аннотацию для внедрения EntityManager'а из Java Persistence API (JPA)
                              для взаимодействия с БД. В отличии от @Autowired, которая используется для внедрения
                              зависимостей в Spring-компонентах. Следовательно, если мы хотим внедрить EntityManager в
                              класс, то используется @PersistenceContext, иначе @Autowired.

         Этой строкой мы объявляем переменную "entityManager", что бы использовать интерфейс EntityManager как рабочий
    инструмент в нашем классе, обеспечивающий:
                           а) взакулисье выполнение управления жизненным циклом персистентных объектов т.е. их поиск,
                              сохранение, добавление, удаление, обновление и извлечения данны при взаимодействии с БД.
                           б) в явно прописанном коде этого класса EntityManager используется для выполнения операций с
                              базой данных, таких как добавление пользователя (метод addUser), удаление пользователя по
                              идентификатору (метод deleteUserById), обновление информации о пользователе
                              (метод updateUser), получение всех пользователей (метод getAllUsers) и получение
                              пользователя по идентификатору (метод getUserById).

         Аннотация @PersistenceContext говорит Spring Framework, что он должен внедрить (предоставить) EntityManager в
     это поле. Когда мы помечаем поле EntityManager аннотацией @PersistenceContext, Spring автоматически создаёт и
     предоставляет EntityManager для внедрения в наш класс, для взаимодействия с БД без необходимости создавать его
     вручную.

         Персистентные объекты в контексте Java Persistence API (JPA) представляют собой объекты, которые могут быть
     сохранены в базе данных. Эти объекты имеют возможность существовать в базе данных даже после завершения работы
     приложения. При изменении персистентного объекта, эти изменения также могут быть автоматически синхронизированы с
     базой данных.

------------------------------------------------------------------------------------------------------------------------

 4. @Override
    public void addUser(User user) {
        entityManager.persist(user);
    }
         Этот метод addUser(User user) используется для добавления нового пользователя в базу данных. Когда он
    вызывается, EntityManager сохраняет переданный объект пользователя в базе данных.
------------------------------------------------------------------------------------------------------------------------

 5. @Override
    public void deleteUserById(Long id) {
        entityManager.createQuery("DELETE FROM User WHERE id = :id").setParameter("id", id).executeUpdate();
    }
         Этот метод deleteUserById(Long id) используется для удаления пользователя из базы данных по его идентификатору.
    Сначала создается запрос на удаление с помощью метода createQuery, где указывается условие удаления
    (DELETE FROM User WHERE id = :id), затем параметр :id устанавливается с помощью метода setParameter, и, наконец,
    запрос выполняется с помощью метода executeUpdate.

------------------------------------------------------------------------------------------------------------------------

 6. @Override
    public void updateUser(User user) {
        entityManager.merge(user);
    }
         Этот метод updateUser(User user) используется для обновления информации о пользователе в базе данных. Когда он
    вызывается, EntityManager обновляет состояние пользователя в базе данных в соответствии с переданным объектом
    пользователя.

------------------------------------------------------------------------------------------------------------------------

 7. @Override
    public List<User> getAllUsers() {
        return entityManager.createQuery("FROM User", User.class).getResultList();
    }
         Этот метод getAllUsers() используется для извлечения всех пользователей из базы данных. Он создает запрос на
    выборку всех объектов User из базы данных с помощью метода createQuery, передавая строку запроса "FROM User", и
    затем возвращает список всех найденных пользователей.

------------------------------------------------------------------------------------------------------------------------

 8. @Override
    public User getUserById(Long id) {
        return entityManager.find(User.class, id);
    }
         Этот метод getUserById(Long id) используется для получения пользователя из базы данных по его идентификатору.
    Когда он вызывается, EntityManager выполняет запрос к базе данных и возвращает объект пользователя с указанным
    идентификатором.

------------------------------------------------------------------------------------------------------------------------

         "Реляционны
         аботанной Эдгаром Коддом. В реляционной модели данные организованы в виде таблиц, где каждая строка
    представляет собой отдельную запись, а каждый столбец - отдельное поле или атрибут. Таблицы могут быть связаны друг
    с другом с помощью ключей, что позволяет эффективно организовывать и извлекать данные.
         Таким образом, реляционная база данных представляет собой набор связанных таблиц, где каждая таблица содержит
    данные об определенной сущности, а связи между таблицами позволяют объединять данные из разных таблиц для выполнения
    сложных запросов.
         По итогу понятие "Реляционный" означает организованную модель хранения данных.

        JPA (Java Persistence API) - стандартный интерфейс для управления реляционными данными в Java-приложениях. Он
    позволяет описывать объекты Java для сохранения в базе данных и выполнять операции чтения и записи данных без
    напрямую написания SQL-запросов. JPA также предоставляет возможность использовать аннотации для сопоставления
    объектов Java с таблицами в базе данных и определения связей между ними, а также API для выполнения запросов к базе
    данных с использованием объектно-ориентированного подхода.

  */