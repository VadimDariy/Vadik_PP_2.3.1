package web.config;

import org.springframework.web.filter.CharacterEncodingFilter;
import org.springframework.web.filter.HiddenHttpMethodFilter;
import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

import javax.servlet.FilterRegistration;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;

public class AppInit extends AbstractAnnotationConfigDispatcherServletInitializer {

    // Метод, указывающий на класс конфигурации
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return null;
    }


    // Добавление конфигурации, в которой инициализируем ViewResolver, для корректного отображения jsp.
    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class<?>[]{
                WebConfig.class
        };
    }


    /* Данный метод указывает url, на котором будет базироваться приложение */
    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }

    @Override
    public void onStartup(ServletContext servletContext) throws ServletException {
        super.onStartup(servletContext);
        FilterRegistration.Dynamic encodingFilter = servletContext.addFilter("encodingFilter", new CharacterEncodingFilter());
        encodingFilter.setInitParameter("encoding", "UTF-8");
        encodingFilter.setInitParameter("forceEncoding", "true");
        encodingFilter.addMappingForUrlPatterns(null, true, "/*");
        registerHiddenFieldFilter(servletContext);
    }

    public void registerHiddenFieldFilter(ServletContext aContext) {
        aContext.addFilter("hiddenHttpMethodFilter",
                new HiddenHttpMethodFilter()).addMappingForUrlPatterns(null, true, "/*");
    }
}

/*      Создадим класс "AppInit", который будет служить для инициализации нашего веб-приложения в контексте Spring. Для
    этого мы унаследуем наш класс "AppInit" от класса "AbstractAnnotationConfigDispatcherServletInitializer", что бы
    переопределить его методы отвечающие за иницмализацию веб-приложения с использованием Spring и аннотаций. Данный
    класс позволяет настраивать веб-приложения без необходимости использования файлов web.xml. В нашем классе AppInit,
    в переопределённых методах мы будем определять конфигурации(настройки Spring), в том числе класс конфигурации,
    область сканирования для компонентов Spring, и маппинг URL для диспетчера сервлетов.

------------------------------------------------------------------------------------------------------------------------

 1. @Override
    protected Class<?>[] getRootConfigClasses() {
        return null;
    }

    Переопределяем данный метод по причине того, что он является обязательным для переопределения в классе наследнике,
    иначе компилятор выдаст ошибку. Внутри него прописываем "null" потому, как в нашем случае отсутствуют
    конфигурационные классы для корневого контекста приложения связанные с настройками бизнес-сервисов, доступа к данным,
    служб безопасности и других несвязанных с веб-слоем аспектов приложения.

------------------------------------------------------------------------------------------------------------------------

 2. @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class<?>[]{
                WebConfig.class
        };
    }

    Этот метод возвращает конфигурационный класс для конфигурации диспетчера сервлетов "WebConfig.class", который
    содержит конфигурации для веб-части приложения, такие как настройки ViewResolver.

------------------------------------------------------------------------------------------------------------------------

 3. @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }

    Этот метод устанавливает базовый URL для веб-приложения. Указание корневого пути ("/") означает, что приложение
    будет обрабатывать все запросы, поскольку после URL-шаблона (наклонного слеша) не следует никаких дополнительных
    символов, что позволяет сервлету обрабатывать все запросы, значение которых будет указано после наклонного слеша.

------------------------------------------------------------------------------------------------------------------------

 4. @Override
    public void onStartup(ServletContext servletContext) throws ServletException {

    4.1 super.onStartup(servletContext); - с помощью ключевого слова "super" вызываем из родительского класса
                          "AbstractAnnotationConfigDispatcherServletInitializer" от которого наследуется класс "AppInit"
                          метод "onStartup()", внутри которого в параметрах в качестве аргумента установлен объект
                          "servletContext" отвечающий за инициализацию включающюю в себя регистрацию основного сервлета
                          DispatcherServlet, настройку Spring контекста, а также обработку всех аннотаций и конфигураций.
                          Данный вызов предоставляет базовую функциональность для старта веб-приложения и включает все
                          необходимые настройки, определенные в родительском классе.

    4.2 FilterRegistration.Dynamic encodingFilter = servletContext.addFilter("encodingFilter", new CharacterEncodingFilter());

       Эта строка регистрирует фильтр для установки кодировки символов где:
            а) FilterRegistration.Dynamic - это тип данных (интерфейс), а encodingFilter - переменная, которой
               присваивается значение. При чём "Dynamic" указывает на то, что значения фильтра можно менять не только до
               запуска приложение, но и динамически во время выполнения приложения;
            б) servletContext - это объект, который содержит в себе все настройки веб-приложения;
            в) addFilter("encodingFilter", new CharacterEncodingFilter()) - это метод который дополнительно добавляет
               в объект "servletContext" фильтор с именем "encodingFilter" и создаёт новый объект фильтра для установки
               кодировки символов запросов и ответов. Это говорит о том, что если програмист устанавливает какую-либо
               конкретную кодировку, например UTF-8, то данный фильтор  будет использоваться при чтении данных любой
               другой кодировки установленной при вводе данных в баузере пользователем из его запросов и записи данных в
               ответы в кодировке UTF-8.

               КОДИРОВКА ПО УМОЛЧАНИЮ: CharacterEncodingFilter распознает кодировку запроса от клиента (браузера),
               конвертирует внутренние данные приложения и управляет кодировкой ответа для корректного взаимодействия с
               базой данных и отображения клиенту.

               ПРИНУДИТЕЛЬНАЯ КОДИРОВКА: В объект CharacterEncodingFilter устанавливается конкретная кодировкадля для
               обязательного использования. Это гарантирует единообразную обработку данных в приложении, независимо от
               указанной клиентом кодировки, обеспечивая предсказуемое поведение.

    ПО ИТОГУ: Эта строка регистрирует фильтр для установки кодировки символов в приложении. Фильтр позволяет распознавать
              и конвертировать кодировку запросов и ответов, а также динамически изменять её во время выполнения приложения.

    4.3 encodingFilter.setInitParameter("encoding", "UTF-8");
              Этот метод принудительно устанавливает кодировку UTF-8 для фильтра "encodingFilter". Параметр "encoding"
              здесь представляет собой имя настраиваемого параметра, к которому можно обратиться для изменения текущей
              кодировки на другую.

    4.4 encodingFilter.setInitParameter("forceEncoding", "true");
              Этот метод устанавливает параметр "forceEncoding" в значение "true" для фильтра "encodingFilter".
              Установка этого параметра в "true" указывает, что необходимо принудительно использовать установленную
              кодировку, игнорируя кодировку, указанную клиентом. Таким образом, все данные внутри приложения будут
              обрабатываться и передаваться с использованием установленной кодировки.

    4.5 encodingFilter.addMappingForUrlPatterns(null, true, "/*");
              Этот метод добавляет маппинг (связывание) фильтра "encodingFilter" с указанным URL-шаблоном. В данном
              случае, фильтр будет применяться ко всем URL, так как указан шаблон "/*", что означает любой URL.
              Параметры метода:

              null: Здесь обычно передается информация о сервлетах, к которым привязан фильтр. Однако, в данном случае,
              используется null, что означает, что фильтр применяется ко всем сервлетам.

              true: Этот параметр указывает, что фильтр будет применяться ко всем дочерним URL-шаблонам. Если указано
              false, то фильтр будет применяться только к точному URL, указанному в третьем параметре.

              -0": Это URL-шаблон, к которому применяется фильтр. В данном случае, "слеш + *" означает все URL.


    4.6 registerHiddenFieldFilter(servletContext);
              Этот метод регистрирует фильтр HiddenHttpMethodFilter для поддержки дополнительных HTTP-методов в
              веб-приложении.
    }

         В методе onStartup вы не возвращаете объект encodingFilter, потому что в данном контексте это не требуется. Метод
    onStartup используется для настройки и инициализации веб-приложения, и нет необходимости возвращать объект фильтра,
    так как его настройки уже применены к объекту servletContext. В данном случае, вы просто регистрируете фильтр и его
    настройки в контексте приложения, чтобы они были применены при запуске приложения.

         Этот метод вызывается при старте приложения. В данном случае, он вызывает метод super.onStartup(servletContext),
    который выполняет стандартную инициализацию. Затем создается и регистрируется фильтр кодировки
    (CharacterEncodingFilter), который устанавливает кодировку для запросов и ответов в UTF-8. Также регистрируется
    фильтр для обработки скрытых методов в HTML-формах (HiddenHttpMethodFilter).

------------------------------------------------------------------------------------------------------------------------

 5. public void registerHiddenFieldFilter(ServletContext aContext) {
        aContext.addFilter("hiddenHttpMethodFilter",
                new HiddenHttpMethodFilter()).addMappingForUrlPatterns(null, true, "/*");
    }

        Этот метод применяет фильтр "HiddenHttpMethodFilter" к входящим запросам и определяет, какие запросы следует
    фильтровать, используя метод addMappingForUrlPatterns(null, true, "/*").

          а) ServletContext aContext - это переменная, представляющая объект типа ServletContext, установлена в методе в
                                       качестве параметра, который принимает аргумент запроса для последующей его
                                       фильтрации.

          б) addFilter("hiddenHttpMethodFilter", new HiddenHttpMethodFilter()) - этот метод создаёт и применяет фильтр,
                                      указанный в параметрах  к входящему запросу, возвращая объект
                                      FilterRegistration.Dynamic, содержащий в себе данные запроса.

                     Параметры метода addFilter():
                    "hiddenHttpMethodFilter" - уникально имя, которое идентифицирует фильтр в рамках веб-приложения.
                    new HiddenHttpMethodFilter() - создаёт новый объект фильтра, использующий HTTP-методы PUT, PATCH и
                                                   DELETE через скрытые поля в HTML-формах.

    Далее объект FilterRegistration.Dynamic, содержаший в себе запрос фильтруется с помощью метода:
          в) addMappingForUrlPatterns(null, true, "/*") -
                    null -  это фильтор который будет обрабатывать все типы запросов (REQUEST,ASYNC, ERROR и т.д.);
                    true - этим параметром мы говорим фильтру, что бы он обрабатывал все без исключения запросы, даже в
                           том случае, если они уже были обработаны другими фильтрами или сервлетом.;
                    "Слеш + *" - это URL-шаблон, этим параметром мы говорим фильтру, что бы он его применял ко всем
                                 входящим запросам с любыми URL.

    ЕСЛИ КОРОТКО, ТО ФУНКЦИОНАЛ ЭТОГО МЕТОДА ПРОЗВУЧИТ ТАК:

         Этот метод регистрирует фильтр "HiddenHttpMethodFilter" для обработки входящих запросов. Указанный фильтр
    использует скрытые поля в HTML-формах для поддержки HTTP-методов PUT, PATCH и DELETE. Метод
    addMappingForUrlPatterns(null, true, "/*") настраивает фильтр для обработки всех типов запросов (null) и применения
    ко всем URL ("/*").

------------------------------------------------------------------------------------------------------------------------



1. Разные виды данных, библиотеки, настройки(водные ресурсы) - необходдимы для функционирования приложения как вода для
                                                               питания жизни;
2. Специфические наборы данных или компонентов(Источник воды) - необходимы для выполнения определённой задачи, так же
                                                                как, например из воды можно приготовить различные
                                                                составы и использовать их в разных направления,
                                                                например: очищенная вода для питья, дисцилированная вода
                                                                для автомобильных аккумуляторов, дождевая вода для полива
                                                                урожая, вода в составе химикатов;
3. Источники данных или конфигураций(Подземные, поверхностные воды) - представляют разные наборы конфигураций в
                                                                приложении, например "подземные воды" могли бы быть
                                                                конфигурациями, необходимыми для работы базы данных, а
                                                                "поверхностные воды" - конфигурациями, связанными с
                                                                веб-интерфейсом.


"Водные ресурсы" представляют собой различные виды данных, библиотеки и настройки, необходимые для функционирования
приложения, аналогично воде, которая необходима для обеспечения жизнедеятельности.

"Источники данных или компонентов" аналогичны специфическим наборам данных или компонентов, которые нужны для выполнения
конкретных задач в приложении, как различные составы воды, которые могут использоваться в разных сферах, такие как
питьевая вода, дистиллированная вода для автомобильных аккумуляторов или дождевая вода для полива растений.

"Источники данных или конфигураций" аналогичны подземным и поверхностным водам, представляя разные наборы конфигураций в
приложении, которые могут быть выбраны в зависимости от задачи, аналогично выбору и использованию подземных или
поверхностных вод для конкретных нужд.

            ЧТО ТАКОЕ КОРНЕВАЯ КОФИГУРАЦИЯ:

         Давайте представим, что ваше веб-приложение, построенное с использованием Spring Framework, подобно системе
    водоснабжения.
    Вода как ресурс: Вода представляет собой ресурс, который ваше веб-приложение (как и жизнь в целом) не может
                     существовать без него. Этот ресурс аналогичен различным данным, библиотекам и настройкам,
                     необходимым для функционирования вашего приложения.
    Разные виды воды: Теперь давайте подумаем о различных видов воды, таких как подземные и поверхностные воды.
                      Подземные воды могут использоваться для наполнения подземных резервуаров, а поверхностные воды -
                      для полива сельского хозяйства. В контексте вашего приложения, это означает, что у вас есть разные
                      наборы данных и компонентов (какие-то общие, а некоторые специфические), необходимые для выполнения
                      разных задач в вашем приложении.
    Источники воды (конфигурации): Подземные воды и поверхностные воды являются разными источниками воды. В вашем
                                   приложении, "источники воды" могли бы представлять собой разные наборы конфигураций.
                                   Например, "подземные воды" могли бы представлять конфигурации, связанные с базой
                                   данных, а "поверхностные воды" - конфигурации, связанные с веб-интерфейсом вашего
                                   приложения.
    Корневая конфигурация: Теперь представьте себе, что корневая конфигурация - это ваш центральный водозабор, откуда
                           исходит вода в вашу систему водоснабжения. Корневая конфигурация в вашем приложении
                           представляет собой часть конфигурации, где определены общие компоненты и настройки, которые
                           должны быть доступны для всего приложения. Это аналогично местоположению центрального
                           водозабора в вашей системе водоснабжения, который обеспечивает водой все остальные части
                           системы.

    Итак, корневая конфигурация - это место, где вы определяете те компоненты и настройки, которые должны быть
    доступными для всего вашего приложения, подобно тому, как центральный водозабор обеспечивает водой всю систему
    водоснабжения.

*/







